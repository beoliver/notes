
# REPL driven development

We currently know how to start a REPL and how to create a jar so that we can run our final application. 

The Term "REPL driven development" is intended to capture the idea that the REPL (Read Eval Print Loop) plays a central role when developing programs. However, this **does not** mean that you will spend your time tying expressions directly into the REPL.

The term "REPL aided development" is also used.

## What is a REPL

See https://clojure.org/guides/repl/introduction

## Loading code

### `load-file`. 

We start clojure and include the jars on the class path, but do **not** include the `src` directory.

```sh 
java -cp "jars/*" clojure.main
```

We can use `load-file` to load any file we want. if the path does not start with a `/` then it is considered relative to the directory that the clojure runtime was started.

```clojure
user=> (load-file "src/example/core.clj")
This is a side effect
#'example.core/greet
user=> (example.core/greet "You")
Hello, You.
nil
```

### `load`. 

```sh
java -cp "jars/*" clojure.main
```

```clojure
user=> (load "/example/core")
Execution error (FileNotFoundException) at user/eval1 (REPL:1).
Could not locate example/core__init.class, example/core.clj or example/core.cljc on classpath.
```

In order to use `load` we need to first add the `src` directory to our class path. Note that `/example/core` mimics the namespace `example.core`.

```sh
java -cp "jars/*:src" clojure.main
```

```clojure
user=> (load "/example/core")
This is a side effect
nil
user=> (example.core/greet "You")
Hello, You.
nil
```

Similar to `load-file` but it returns `nil`.

### `require`

```sh
java -cp "jars/*" clojure.main
```

```clojure 
user=> (require '[example.core :as core])
Execution error (FileNotFoundException) at user/eval1 (REPL:1).
Could not locate example/core__init.class, example/core.clj or example/core.cljc on classpath.
```

```sh
java -cp "jars/*:src" clojure.main
```

```clojure 
user=> (require '[example.core :as core])
This is a side effect
nil 
user=> (core/greet "Ben")
Hello, Ben.
```


### Reloading a file. 

What happens if we make a change to the file? Make sure that you are in the REPL and have already required the namespace

```sh
java -cp "jars/*:src" clojure.main
```

```clojure 
user=> (require '[example.core :as core])
This is a side effect
nil 
user=> (core/greet "Ben")
Hello, Ben.
```

Now, let's change the content of 'src/example/core.clj' to contain the following:

```clojure
(ns example.core)

(println "This is ANOTHER side effect")

(defn greet [name]
  (println (format "BYE BYE, %s." name)))
```

The capitalized words are changes.

```clojure
user=> (require '[example.core :as core])
nil 
user=> (core/greet "Ben")
Hello, Ben.
```
That's interesting. The `require` function seems to cache the result. This means that our changed file is not picked up.



```clojure
user=> (load-file "src/example/core.clj")
#'example.core/greet
user=> (require '[example.core :as core])
nil
user=> (core/greet "Ben")
Hello, Ben.
nil
```

Let's update the greet function to say "Goodbye".

```clojure
(ns example.core)

(defn greet [name]
  (println (format "Goodbye, %s." name)))
```

```clojure
user=> (load-file "src/example/core.clj")
#'example.core/greet
user=> (core/greet "Ben")
Goodbye, Ben.
nil
```

Notice that we did not need to call `require` again. 




