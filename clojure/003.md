[Previous](./002.md)

# REPL driven development

We currently know how to start a REPL and how to create a jar so that we can run our final application.

The Term "REPL driven development" is intended to capture the idea that the REPL (Read Eval Print Loop) plays a central role when developing programs. However, this **does not** mean that you will spend your time tying expressions directly into the REPL.

The term "REPL aided development" is also used.

## What is a REPL

See https://clojure.org/guides/repl/introduction

## Loading code

### `load-file`. 

We start clojure and include the jars on the class path, but do **not** include the `src` directory.

```sh 
java -cp "jars/*" clojure.main
```

We can use `load-file` to load any file we want. if the path does not start with a `/` then it is considered relative to the directory that the clojure runtime was started.

```clojure
user=> (load-file "src/example/core.clj")
This is a side effect
#'example.core/greet
user=> (example.core/greet "You")
Hello, You.
nil
```

### `load`. 

```sh
java -cp "jars/*" clojure.main
```

```clojure
user=> (load "/example/core")
Execution error (FileNotFoundException) at user/eval1 (REPL:1).
Could not locate example/core__init.class, example/core.clj or example/core.cljc on classpath.
```

In order to use `load` we need to first add the `src` directory to our class path. Note that `/example/core` mimics the namespace `example.core`.

```sh
java -cp "jars/*:src" clojure.main
```

```clojure
user=> (load "/example/core")
This is a side effect
nil
user=> (example.core/greet "You")
Hello, You.
nil
```

Similar to `load-file` but it returns `nil`.

### `require`

```sh
java -cp "jars/*" clojure.main
```

```clojure 
user=> (require '[example.core :as core])
Execution error (FileNotFoundException) at user/eval1 (REPL:1).
Could not locate example/core__init.class, example/core.clj or example/core.cljc on classpath.
```

```sh
java -cp "jars/*:src" clojure.main
```

```clojure 
user=> (require '[example.core :as core])
This is a side effect
nil 
user=> (core/greet "Ben")
Hello, Ben.
```


### Reloading a file. 

What happens if we make a change to the file? Make sure that you are in the REPL and have already required the namespace

```sh
java -cp "jars/*:src" clojure.main
```

```clojure 
user=> (require '[example.core :as core])
This is a side effect
nil 
user=> (core/greet "Ben")
Hello, Ben.
```

Now, let's change the content of 'src/example/core.clj' to contain the following:

```clojure
(ns example.core)

(println "This is ANOTHER side effect")

(defn greet [name]
  (println (format "BYE BYE, %s." name)))
```

The capitalized words are changes.

```clojure
user=> (require '[example.core :as core])
nil 
user=> (core/greet "Ben")
Hello, Ben.
```
That's interesting. The `require` function seems to cache the result. This means that our changed file is not picked up.



```clojure
user=> (load-file "src/example/core.clj")
#'example.core/greet
user=> (require '[example.core :as core])
nil
user=> (core/greet "Ben")
Hello, Ben.
nil
```

Let's update the greet function to say "Goodbye".

```clojure
(ns example.core)

(defn greet [name]
  (println (format "Goodbye, %s." name)))
```

```clojure
user=> (load-file "src/example/core.clj")
#'example.core/greet
user=> (core/greet "Ben")
Goodbye, Ben.
nil
```

Notice that we did not need to call `require` again. 



## Starting the prepl

https://github.com/clojure/clojure/blob/8c8e4f6ef21f3d0f59deb60cdc7e1b584f596d59/src/jvm/clojure/lang/RT.java#L513

https://github.com/clojure/clojure/blob/8c8e4f6ef21f3d0f59deb60cdc7e1b584f596d59/src/clj/clojure/core/server.clj#L160

```clojure
user> (def server 
        (clojure.core.server/start-server
         {:name "sockserver" 
          :port 7777
          :accept 'clojure.core.server/io-prepl}))
#'user/server
user> server
#object[java.net.ServerSocket 0x6377f56e "ServerSocket[addr=localhost/127.0.0.1,localport=7777]"]
user> (.close server)
nil
```

By including the following jvm options it is possible to start a server directly - for example

```clojure
-Dclojure.server.repl={:port 7777 :accept clojure.core.server/io-prepl}
```

For example, to just craete an "empty" repl, we could run the following clojure cli command

```bash
$ clj -J-Dclojure.server.repl="{:port 7777 :accept clojure.core.server/io-prepl}"
Clojure 1.10.3
user=> 
```

or using java directly 

```bash 
java -Dclojure.server.repl="{:port 7777 :accept clojure.core.server/io-prepl}" -cp "jars/*" clojure.main
```


you can connect using `nc` as follows: 

```
rlwrap --remember --quote-characters '\"' --break-chars "(){}[],^%#@\";:'" nc localhost 7777
```

